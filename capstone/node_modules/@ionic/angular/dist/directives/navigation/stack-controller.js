import * as tslib_1 from "tslib";
import { bindLifecycleEvents } from '../../providers/angular-delegate';
import { computeStackId, destroyView, getUrl, insertView, isTabSwitch, toSegments } from './stack-utils';
var StackController = /** @class */ (function () {
    function StackController(tabsPrefix, containerEl, router, navCtrl, zone) {
        this.containerEl = containerEl;
        this.router = router;
        this.navCtrl = navCtrl;
        this.zone = zone;
        this.viewsSnapshot = [];
        this.views = [];
        this.skipTransition = false;
        this.nextId = 0;
        this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;
    }
    StackController.prototype.createView = function (ref, activatedRoute) {
        var url = getUrl(this.router, activatedRoute);
        var element = (ref && ref.location && ref.location.nativeElement);
        var unlistenEvents = bindLifecycleEvents(ref.instance, element);
        return {
            id: this.nextId++,
            stackId: computeStackId(this.tabsPrefix, url),
            unlistenEvents: unlistenEvents,
            element: element,
            ref: ref,
            url: url,
        };
    };
    StackController.prototype.getExistingView = function (activatedRoute) {
        var activatedUrlKey = getUrl(this.router, activatedRoute);
        var view = this.views.find(function (vw) { return vw.url === activatedUrlKey; });
        if (view) {
            view.ref.changeDetectorRef.reattach();
        }
        return view;
    };
    StackController.prototype.setActive = function (enteringView) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, direction, animation, leavingView;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.navCtrl.consumeTransition(), direction = _a.direction, animation = _a.animation;
                        leavingView = this.activeView;
                        if (isTabSwitch(enteringView, leavingView)) {
                            direction = 'back';
                            animation = undefined;
                        }
                        this.insertView(enteringView, direction);
                        return [4 /*yield*/, this.transition(enteringView, leavingView, animation, this.canGoBack(1), false)];
                    case 1:
                        _b.sent();
                        requestAnimationFrame(function () { return _this.cleanup(); });
                        return [2 /*return*/];
                }
            });
        });
    };
    StackController.prototype.canGoBack = function (deep, stackId) {
        if (stackId === void 0) { stackId = this.getActiveStackId(); }
        return this.getStack(stackId).length > deep;
    };
    StackController.prototype.pop = function (deep, stackId) {
        var _this = this;
        if (stackId === void 0) { stackId = this.getActiveStackId(); }
        return this.zone.run(function () {
            var views = _this.getStack(stackId);
            var view = views[views.length - deep - 1];
            return _this.navCtrl.navigateBack(view.url);
        });
    };
    StackController.prototype.startBackTransition = function () {
        var leavingView = this.activeView;
        if (leavingView) {
            var views = this.getStack(leavingView.stackId);
            var enteringView = views[views.length - 2];
            enteringView.ref.changeDetectorRef.reattach();
            this.transition(enteringView, // entering view
            leavingView, // leaving view
            'back', true, true);
        }
    };
    StackController.prototype.endBackTransition = function (shouldComplete) {
        if (shouldComplete) {
            this.skipTransition = true;
            this.pop(1);
        }
    };
    StackController.prototype.getLastUrl = function (stackId) {
        var views = this.getStack(stackId);
        return views.length > 0 ? views[views.length - 1] : undefined;
    };
    StackController.prototype.getActiveStackId = function () {
        return this.activeView ? this.activeView.stackId : undefined;
    };
    StackController.prototype.destroy = function () {
        this.containerEl = undefined;
        this.views.forEach(destroyView);
        this.activeView = undefined;
        this.views = [];
    };
    StackController.prototype.getStack = function (stackId) {
        return this.views.filter(function (v) { return v.stackId === stackId; });
    };
    StackController.prototype.insertView = function (enteringView, direction) {
        this.activeView = enteringView;
        this.views = insertView(this.views, enteringView, direction);
    };
    StackController.prototype.cleanup = function () {
        var activeRoute = this.activeView;
        var views = this.views;
        this.viewsSnapshot
            .filter(function (view) { return !views.includes(view); })
            .forEach(function (view) { return destroyView(view); });
        views.forEach(function (view) {
            if (view !== activeRoute) {
                var element = view.element;
                element.setAttribute('aria-hidden', 'true');
                element.classList.add('ion-page-hidden');
                view.ref.changeDetectorRef.detach();
            }
        });
        this.viewsSnapshot = views.slice();
    };
    StackController.prototype.transition = function (enteringView, leavingView, direction, showGoBack, progressAnimation) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var enteringEl, leavingEl, containerEl;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.runningTransition !== undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.runningTransition];
                    case 1:
                        _a.sent();
                        this.runningTransition = undefined;
                        _a.label = 2;
                    case 2:
                        if (this.skipTransition) {
                            this.skipTransition = false;
                            return [2 /*return*/];
                        }
                        enteringEl = enteringView ? enteringView.element : undefined;
                        leavingEl = leavingView ? leavingView.element : undefined;
                        containerEl = this.containerEl;
                        if (!(enteringEl && enteringEl !== leavingEl)) return [3 /*break*/, 5];
                        enteringEl.classList.add('ion-page', 'ion-page-invisible');
                        if (enteringEl.parentElement !== containerEl) {
                            containerEl.appendChild(enteringEl);
                        }
                        return [4 /*yield*/, containerEl.componentOnReady()];
                    case 3:
                        _a.sent();
                        this.runningTransition = containerEl.commit(enteringEl, leavingEl, {
                            deepWait: true,
                            duration: direction === undefined ? 0 : undefined,
                            direction: direction,
                            showGoBack: showGoBack,
                            progressAnimation: progressAnimation
                        });
                        return [4 /*yield*/, this.runningTransition];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return StackController;
}());
export { StackController };
